---
layout: post
title: "TDD"
permalink: /inside-complexity/tdd/
---

### C’est quoi le développement dirigé par les tests (TDD) ?

- Le concept magique où **tu dois d’abord écrire le test d’un truc qui n’existe pas**. Ouais, comme écrire le mode d’emploi d’une machine que tu n’as pas encore inventée.

- Ensuite, tu fais en sorte que ton code passe ce test, même si c’est moche. Puis tu refactorises, parce que sinon tu vas pleurer en production.

- En gros : **tu ne codes rien si t’as pas déjà écrit le test**. Oui, ça fait mal au cerveau.


---

### Les différences entre les tests unitaires et les tests de bout en bout

- **Tests unitaires** : tu vérifies qu’une petite fonction ou méthode fait ce qu’elle est censée faire. Bref, est-ce que ton lego tient debout tout seul ?

- **Tests d’acceptation** : tu vérifies que la maison entière en legos ne s’effondre pas quand tu touches la porte.

- **Tests d’intégration** : là tu pries pour que ton code s’entende avec les librairies tierces, frameworks ou bases de données qui ont été écrits par quelqu’un qui n’a jamais entendu parler de toi.


---

### Comment écrire un bon test unitaire ?

1. Tu crées l’objet (wow, quelle surprise).

2. Tu lui files des dépendances remplaçables, parce qu’on adore les mocks moches.

3. Tu fais joujou avec.

4. Tu vérifies qu’il fait bien son boulot. Spoiler : au début, ça rate.

5. Tu corriges pour que ça passe.

6. Tu refactorises parce que ton code ressemble à une serpillière.

7. Tu recommences. Et encore. Et encore. (Bienvenue dans le cycle sans fin).


---

### C’est quoi le couplage ?

Quand deux morceaux de code sont **si collés ensemble** qu’à chaque fois que tu touches l’un, tu flingues l’autre. Genre les écouteurs que tu retrouves dans ta poche.

---

### C’est quoi la cohésion ?

Une classe qui parse à la fois des dates et des URL ? Bravo, tu viens d’inventer la classe couteau-suisse immonde.  
Une classe qui parse juste la ponctuation d’une URL mais pas l’hôte ni le protocole ? Pareil, ça sert à rien. Moralité : **une classe doit représenter un concept, pas tes pulsions de dev insomniaque.**

---

### Les liens entre objets

En POO, les objets discutent entre eux avec des messages. Un peu comme des cellules vivantes. Sauf qu’ici, quand ça foire, **ça pète une stacktrace de 200 lignes** au lieu de donner le cancer.

---

### Comment savoir si le système fonctionne bien ?

- Teste le plus tôt possible (avant que ça te pète à la gueule).

- Intègre le plus tôt possible (sinon ça va exploser en merge).

- Déploie le plus souvent possible (comme ça tes bugs vont en prod plus vite et tu les corriges “agilement”).


---

### Comment assurer la qualité du système ?

- Ajoute les fonctionnalités petit à petit mais toujours déployables. Pas de prototype crado qui vit 3 ans en prod, merci.

- Et surtout : **écoute les retours des utilisateurs**. Oui, même celui qui t’écrit en Comic Sans MS sur Jira.


---

### À quoi servent les mocks ?

- À pas attendre que toute la planète soit codée pour tester ton bout de fonction.

- À simuler tes dépendances, parce que démarrer un cluster Kubernetes pour vérifier un “Hello World”, c’est peut-être un peu abusé.

- Non, ce n’est pas de la triche. C’est de la survie.


---

### Comment tester une fonctionnalité ?

1. Tu écris un test d’acceptation qui simule l’utilisateur lambda (celui qui clique n’importe où).

2. Tu découpes en petits tests unitaires parce que sinon t’y arrives jamais.

3. Tu mets des mocks partout, comme du scotch sur une machine en panne.

4. Tu cycles : test → code → test → code, jusqu’à ce que ton cerveau fonde.

5. Tu balances ça dans le build pour que la CI te hurle dessus à chaque commit.


---

### Comment déployer souvent ?

- Tu automatises le build, parce que cliquer sur “Compiler” manuellement c’est sympa en 1998.

- Tu déclenches le build dès qu’un commit arrive.

    - Tu récupères la dernière version.

    - Tu compiles et tu testes.

    - Tu intègres et tu packages.

    - Tu déploies dans un environnement qui ressemble (un peu) à la prod.

    - Et tu testes encore.

- Bref : si t’as pas un pipeline CI/CD, tu fais du tricot, pas du dev.