---
layout: post
title: "TDD"
---

**C’est quoi le TDD ?**

Le **Test Driven Development**, ou _développement dirigé par les tests_ pour les puristes, c’est une manière de coder qui force ton cerveau à réfléchir **avant** d’écrire la moindre ligne.  
Tu veux une nouvelle fonctionnalité ? D’abord, tu écris **le test**.  
Et ce test, c’est ta promesse : _“Voilà ce que ce truc doit faire, ni plus ni moins.”_

Ensuite seulement, tu écris juste **assez de code** pour que le test passe.  
Si ta conception est foireuse, tu vas le sentir tout de suite : écrire le test va te faire souffrir.  
Et c’est le but. Le TDD, c’est un miroir de ton architecture.

**Règle d’or :** pas de test → pas de code.

**Tests unitaires, intégration, bout en bout… c’est quoi la différence ?**

- **Tests unitaires** : tu vérifies qu’une seule brique de ton code fait bien ce qu’elle promet. Une fonction, une classe, peu importe. C’est ton garde-fou pour la qualité du code.
- **Tests d’intégration** : là tu testes comment ton code discute avec le reste du monde : une base de données, un framework, une librairie.
- **Tests d’acceptation (ou end-to-end)** : c’est la vision macro. Est-ce que tout ton système tourne rond, du clic utilisateur jusqu’à la base de données et retour ?

**Comment écrire un vrai bon test unitaire**

Un bon test unitaire, c’est une mini-histoire :

1. Tu **crées ton objet**.
2. Tu lui files des dépendances propres et remplaçables.
3. Tu lui fais faire ce qu’il est censé faire.
4. Tu vérifies qu’il s’est comporté comme prévu.
5. Tu vois le test échouer.
6. Tu écris le code pour le faire passer.
7. Tu refactores pour rendre ça plus clean.
8. Tu recommences.

C’est tout. Pas de magie. Juste de la rigueur.

**Le couplage, ou pourquoi ton code te déteste**

Le **couplage**, c’est quand un bout de ton code est tellement collé à un autre que tu ne peux plus rien changer sans tout casser.  
Un système **faiblement couplé**, c’est comme des Lego : tu peux changer une brique sans tout exploser.

**La cohésion, l’autre face de la médaille**

Une classe doit représenter **un concept clair**.  
Si ta classe parse à la fois des URLs et des dates… c’est mort.  
Si elle ne gère qu’une partie d’une URL (genre juste la ponctuation)… c’est pas mieux.  
Une classe doit être **centrée**. Cohérente. Prévisible.


**Les objets, c’est comme des cellules**

En POO, tes objets se parlent entre eux, s’envoient des messages, collaborent.  
Un peu comme un organisme vivant.  
Et plus tes “cellules” sont indépendantes, plus ton système évolue sans douleur.



**Comment savoir si ton système est sain ?**

Simple :

- **Teste tôt**
- **Intègre souvent**
- **Déploie tout le temps**

Tu veux savoir si ton code marche ? Mets-le face à la réalité. Rien ne remplace un vrai déploiement.

**La qualité, c’est pas un sprint, c’est une boucle**

Construis ton appli **fonctionnalité par fonctionnalité**, mais toujours en version _déployable_.  
Chaque incrément doit traverser **tout le système**.  
Et dès que tu as du feedback, tu améliores. Encore et encore.



**Les mocks, c’est pas de la triche**

Un **mock**, c’est juste un acteur de doublure.  
Il te permet de tester un comportement complexe sans tout le décor autour.  
Mais leur vraie utilité, c’est de t’obliger à **identifier tes dépendances**.  
Et quand ton code devient trop dépendant, tu le sens tout de suite.



**Tester une fonctionnalité sans t’arracher les cheveux**

1. Commence par un **test d’acceptation** : “voici ce que l’utilisateur veut faire”.
2. Découpe ton problème en **unités testables**.
3. Utilise des **mocks** là où le vrai code n’existe pas encore.
4. Écris des tests unitaires jusqu’à ce que ta fonctionnalité soit solide.
5. Branche ton test d’acceptation dans le build.



**Déployer souvent, c’est pas un luxe**

Automatise **tout** :

- Le build
- Les tests
- Le packaging
- Le déploiement sur un environnement proche de la prod

Et fais-le à chaque commit. Oui, à chaque.  
Parce que la vraie sécurité : c’est la **livraison continue**.


Souviens-toi :

Le TDD, c’est pas écrire des tests.  
C’est apprendre à mieux penser ton code.